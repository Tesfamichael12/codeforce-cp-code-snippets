{

	"Code Snippet": {
		"scope": "",
		"prefix": "sm",
		"body": [
			"def solve():",
			"    n = int(input())",
			"    n, m = map(int, input().split())",
			"    arr = list(map(int, input().split()))",
			"    $0",
			"",
			"",
			"# t = 1",
			"t = int(input())",
			"for _ in range(t):",
			"    solve()"
		],
		"description": "Template for solve function"
	},
	"alltemp": {
		"scope": "",
		"prefix": "alltemp",
		"body": [
			"import sys",
			"import math",
			"import heapq",
			"from collections import defaultdict, Counter, deque",
			"from bisect import bisect_left, bisect_right",
			"from itertools import permutations, combinations, accumulate",
			"from functools import lru_cache, cmp_to_key",
			"from random import randint",
			"from operator import itemgetter",
			"from math import gcd, ceil, floor, sqrt, log2",
			"",
			"# Fast input/output",
			"input = sys.stdin.readline",
			"output = sys.stdout.write",
			"",
			"# Utility functions for input",
			"def iinp(): return int(input().strip())  # Single integer",
			"def linp(): return list(map(int, input().strip().split()))  # List of integers",
			"def sinp(): return input().strip()  # Single string",
			"def minp(): return map(int, input().strip().split())  # Multiple integers",
			"def flinp(): return list(map(float, input().strip().split()))  # List of floats",
			"",
			"# Utility functions for output",
			"def yn(condition): output(\"YES\\n\" if condition else \"NO\\n\")",
			"def yes_no(value): return \"YES\" if value else \"NO\"",
			"",
			"# Math shortcuts",
			"mod = 10**9 + 7",
			"inf = float('inf')",
			"lcm = lambda a, b: (a * b) // gcd(a, b)",
			"",
			"# Randomization (for stress testing or randomized algorithms)",
			"rand = randint(1, int(1e9))",
			"xor = lambda x: x ^ rand",
			"",
			"# Debugging helpers (remove or comment out in actual contests)",
			"def debug(*args): print(\"DEBUG:\", *args, file=sys.stderr)",
			"",
			"# Generic binary search template",
			"def binary_search(array, target):",
			"    lo, hi = 0, len(array) - 1",
			"    while lo <= hi:",
			"        mid = (lo + hi) // 2",
			"        if array[mid] < target:",
			"            lo = mid + 1",
			"        elif array[mid] > target:",
			"            hi = mid - 1",
			"        else:",
			"            return mid",
			"    return -1",
			"",
			"# Graph helpers",
			"def bfs(graph, start):",
			"    visited = set()",
			"    queue = deque([start])",
			"    while queue:",
			"        node = queue.popleft()",
			"        if node not in visited:",
			"            visited.add(node)",
			"            queue.extend(graph[node] - visited)",
			"    return visited",
			"",
			"def dfs(graph, start, visited=None):",
			"    if visited is None:",
			"        visited = set()",
			"    visited.add(start)",
			"    for neighbor in graph[start] - visited:",
			"        dfs(graph, neighbor, visited)",
			"    return visited",
			"",
			"# Modular arithmetic",
			"def mod_add(a, b, m=mod): return (a + b) % m",
			"def mod_sub(a, b, m=mod): return (a - b + m) % m",
			"def mod_mul(a, b, m=mod): return (a * b) % m",
			"def mod_exp(a, b, m=mod):",
			"    result = 1",
			"    while b:",
			"        if b & 1:",
			"            result = result * a % m",
			"        a = a * a % m",
			"        b >>= 1",
			"    return result",
			"",
			"# Main function",
			"def solve():",
			"    n = iinp()  ",
			"    arr = linp()  ",
			"    $0",
			"",
			"# Driver code",
			"if __name__ == \"__main__\":",
			"    sys.setrecursionlimit(10**6)  # For deep recursion in DFS/DP",
			"    t = iinp()  # Number of test cases",
			"    for _ in range(t):",
			"        solve()"
		],
		"description": "Template with utility functions and imports"
	},
	"goall": {
		"scope": "",
		"prefix": "goall",
		"body": [
			"# Author: Tesfamichael Tafere",
			"",
			"import sys",
			"from collections import defaultdict, Counter, deque",
			"from bisect import bisect_left, bisect_right",
			"from itertools import permutations, combinations, accumulate",
			"from functools import lru_cache, cmp_to_key",
			"from random import randint",
			"from operator import itemgetter",
			"from math import gcd, ceil, floor, sqrt, log2",
			"from copy import deepcopy",
			"",
			"# Fast input/output",
			"input = sys.stdin.readline",
			"output = sys.stdout.write",
			"",
			"# Utility functions for input",
			"def iinp(): return int(sys.stdin.readline().strip())",
			"def linp(): return list(map(int, sys.stdin.readline().strip().split()))",
			"def sinp(): return sys.stdin.readline().strip()",
			"def minp(): return map(int, sys.stdin.readline().strip().split())",
			"def mat_int_inp(n): return [list(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]",
			"def mat_str_inp(n): return [list(sys.stdin.readline().strip()) for _ in range(n)]",
			"",
			"# Utility functions for output",
			"def yn(condition): output(\"YES\\n\" if condition else \"NO\\n\")",
			"def yes_no(value): return \"YES\" if value else \"NO\"",
			"",
			"# Math shortcuts",
			"mod = 10**9 + 7",
			"inf = float('inf')",
			"lcm = lambda a, b: (a * b) // gcd(a, b)",
			"fact = lambda n: 1 if n == 0 else n * fact(n-1)",
			"log = lambda a, b: (log2(b)) // (log2(a))  # log b in base a",
			"",
			"# Number theory ",
			"def lcm(a, b): return (a * b) // gcd(a, b)",
			"",
			"def is_prime(n):",
			"    if n < 2: return False",
			"    for i in range(2, int(sqrt(n)) + 1):",
			"        if n % i == 0: return False",
			"    return True",
			"",
			"def get_divisors(n):",
			"    divs = []",
			"    for i in range(1, int(sqrt(n)) + 1):",
			"        if n % i == 0:",
			"            divs.append(i)",
			"            if i != n//i:",
			"                divs.append(n//i)",
			"    return sorted(divs)",
			"",
			"# Modular arithmetic ",
			"def mod_add(a, b, m=mod): return (a + b) % m",
			"def mod_mul(a, b, m=mod): return (a * b) % m",
			"def mod_pow(a, b, m=mod):",
			"    res = 1",
			"    while b > 0:",
			"        if b & 1: res = (res * a) % m",
			"        a = (a * a) % m",
			"        b >>= 1",
			"    return res",
			"",

			"# Commonly needed functions",
			"def get_first_el(data):",
			"    return next(iter(data))",
			"",
			"def inbound(i, j, n, m):",
			"    return 0 <= i < n and 0 <= j < m",
			"",
			"def prefix_sum(arr):",
			"    return list(accumulate(arr))",
			"",
			"def prefix_and_suffix(nums):",
			"    n = len(nums)",
			"    prefix = [1] * (n + 1)",
			"    suffix = [1] * (n + 1)",
			"",
			"    for i in range(n):",
			"        prefix[i+1] = prefix[i] * nums[i]",
			"",
			"    for i in range(n-1, -1, -1):",
			"        suffix[i] = suffix[i+1] * nums[i]",
			"",
			"    return [prefix, suffix]",
			"",
			"def prifix_2D_sum(mat):",
			"    rows, cols = len(mat), len(mat[0])",
			"    grid = deepcopy(mat)",
			"    # append trailing zeros for negative indices",
			"    grid.append([0] * cols)",
			"    for row in grid:",
			"        row.append(0)",
			"",
			"    # build a 2D prefix sum",
			"    for i in range(rows):",
			"        for j in range(cols):",
			"            grid[i][j] += grid[i-1][j] + grid[i][j-1] - grid[i-1][j-1]",
			"",
			"    return grid",
			"",
			"def binary_search(arr, x):",
			"    l, r = 0, len(arr)-1",
			"    while l <= r:",
			"        m = (l + r) // 2",
			"        if arr[m] == x: return m",
			"        if arr[m] < x: l = m + 1",
			"        else: r = m - 1",
			"    return -1",
			"",
			"def max_subarray_sum(arr):",
			"    max_sum, cur = arr[0], 0",
			"    for n in arr:",
			"        cur = max(0, cur) + n",
			"        max_sum = max(max_sum, cur)",
			"    return max_sum",
			"    # curr_sum = max_sum = arr[0]",
			"    # for x in arr[1:]:",
			"    #     curr_sum = max(x, curr_sum + x)",
			"    #     max_sum = max(max_sum, curr_sum)",
			"    # return max_sum",
			"",
			"def rotate_array(arr, k):",
			"    n = len(arr)",
			"    k = k % n",
			"    return arr[-k:] + arr[:-k]",
			"",
			"# Sliding Window template ",
			"def Sliding_window(arr):",
			"    n = len(arr)",
			"    left = curr_sum = ans = 0",
			"    for right in range(n):",
			"        # update the window",
			"        curr_sum += arr[right]",
			"        ",
			"        # Shrink the window ",
			"        # while left <= right and condition: ",
			"        #     curr_sum -= arr[left]",
			"        #     left += 1",
			"        ",
			"        ans = max(ans, right - left + 1)",
			"    return ans",
			"",
			"# Randomization (for stress testing or randomized algorithms)",
			"rand = randint(1, int(1e9))",
			"xor = lambda x: x ^ rand",
			"",
			"# Debugging helpers ",
			"# def debug(*args): print(\"DEBUG:\", *args, file=sys.stderr)",
			"",
			"",
			"#******************** Main function *************************#",
			"",
			"def solve():",
			"    n = iinp()",
			"    n, m = minp()",
			"    arr = linp()",
			"    ",
			"    $0",
			"    ",
			"",
			"if __name__ == \"__main__\":",
			"    t = 1",
			"    t = iinp()",
			"    for _ in range(t):",
			"        solve()"

		],
		"description": "Template with utility functions and imports by Tesfamichael Tafere"
	},
	"go": {
			"scope": "",
			"prefix": "go",
			"body": [
				"import sys; from collections import defaultdict, Counter, deque; from bisect import bisect_left, bisect_right; from random import randint",
				"",
				"def numi(): return int(sys.stdin.readline().strip())",
				"def numsi(): return list(map(int, sys.stdin.readline().strip().split()))",
				"def wordi(): return sys.stdin.readline().strip()",
				"def map_int(): return map(int, sys.stdin.readline().strip().split())",
				"def map_str(): return map(str, sys.stdin.readline().strip().split())",
				"def test(input=0): return numi() if not input else input",
				"def yn(condition): print(\"YES\" if condition else \"NO\")",
				"rand = randint(1, int(1e9)); xor = lambda x: x ^ rand",
				"",
				"def solve():",
				"    n = numi()",
				"    n, m = map_int()",
				"    arr = numsi()",
				"    ",
				"    $0",
				"",
				"",
				"for _ in range(test()):",
				"    solve()"
			],
			"description": "CP Template"
		},

	"dsu": {
			"scope": "",
			"prefix": "dsu",
			"body": [
				"class UnionFind:",
				"    def __init__(self):",
				"        self.root = dict()",
				"        self.size = defaultdict(lambda: 1)",
				"    def find(self, X):",
				"        if X not in self.root:",
				"            self.root[X] = X",
				"            return X",
				"        while X != self.root[X]:",
				"            self.root[X] = self.root[self.root[X]]",
				"            X = self.root[X]",
				"        return self.root[X]",
				"    def union(self, X, Y):",
				"        rootX, rootY = self.find(X), self.find(Y)",
				"        if rootX != rootY:",
				"            if self.size[rootX] > self.size[rootY]:",
				"                self.root[rootY] = rootX",
				"                self.size[rootX] += self.size[rootY]",
				"            else:",
				"                self.root[rootX] = rootY",
				"                self.size[rootY] += self.size[rootX]"
			],
			"description": "CP Template"
		},


	"bootstrap": {
		"scope": "",
		"prefix": "bootstrap",
		"body": [
			"from types import GeneratorType",
			"def bootstrap(f, stack=[]):",
			"    def wrappedfunc(*args, **kwargs):",
			"        if stack:",
			"            return f(*args, **kwargs)",
			"        else:",
			"            to = f(*args, **kwargs)",
			"            while True:",
			"                if type(to) is GeneratorType:",
			"                    stack.append(to)",
			"                    to = next(to)",
			"                else:",
			"                    stack.pop()",
			"                    if not stack:",
			"                        break",
			"                    to = stack[-1].send(to)",
			"            return to",
			"    return wrappedfunc"
		],
		"description": "Bootstrap function for recursive generators"
	}
}